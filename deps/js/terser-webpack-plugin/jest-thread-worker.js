import*as e from"node:worker_threads";import*as t from"node:module";var r={752:(e,t)=>{let r,o;t.eJ=t.a5=t.SP=t.A3=t.tw=t.l5=t.Xu=t.SH=void 0,t.l5=0,t.SH=1,t.Xu=2,t.tw=3,t.a5=0,t.A3=1,t.eJ=2,t.SP=4,function(e){e.STARTING="starting",e.OK="ok",e.OUT_OF_MEMORY="oom",e.RESTARTING="restarting",e.SHUTTING_DOWN="shutting-down",e.SHUT_DOWN="shut-down"}(r||(r={})),function(e){e.STATE_CHANGE="state-change"}(o||(o={}))}},o={};function n(e){var t=o[e];if(void 0!==t)return t.exports;var a=o[e]={exports:{}};return r[e](a,a.exports,n),a.exports}n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{const r=(o={default:()=>e.default},a={},n.d(a,o),a);var o,a;const s=(e=>{var t={};return n.d(t,e),t})({createRequire:()=>t.createRequire});var u=n(752);let c=null,d=[],f=!1;const i=(0,s.createRequire)(import.meta.url),l=e=>{switch(e[0]){case u.l5:const t=e;c=t[2],d=t[3],process.env.JEST_WORKER_ID=t[4];break;case u.SH:const o=e;!function(e,t){const r=i(c);let o;function n(){y(o,r,t,p,h)}o="default"===e?r.__esModule?r.default:r:r[e],!f&&r.setup?(f=!0,y(r.setup,r,d,n,w)):n()}(o[2],o[3]);break;case u.Xu:!function(){const e=i(c);e.teardown?y(e.teardown,e,[],T,T):T()}();break;case u.tw:!function(){if(r.default.isMainThread)throw new Error("Child can only be used on a forked process");const e=[u.SP,process.memoryUsage().heapUsed];r.default.parentPort?.postMessage(e)}();break;default:throw new TypeError(`Unexpected request from parent process: ${e[0]}`)}};function p(e){if(r.default.isMainThread)throw new Error("Child can only be used on a forked process");r.default.parentPort?.postMessage([u.a5,e])}function h(e){return m(e,u.A3)}function w(e){return m(e,u.eJ)}function m(e,t){if(r.default.isMainThread)throw new Error("Child can only be used on a forked process");null==e&&(e=new Error('"null" or "undefined" thrown')),r.default.parentPort?.postMessage([t,e.constructor&&e.constructor.name,e.message,e.stack,"object"==typeof e?{...e}:e])}function T(){r.default.parentPort?.removeListener("message",l)}function y(e,t,r,o,n){let a;try{a=e.apply(t,r)}catch(e){return void n(e)}"object"!=typeof a&&"function"!=typeof a||"function"!=typeof a?.then?o(a):a.then(o,n)}r.default.parentPort?.on("message",l)})();
//# sourceMappingURL=jest-thread-worker.js.map